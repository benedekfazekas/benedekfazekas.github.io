<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><meta content="Demo how to clean up a messy namespace, function using cider and clj-refactor in emacs" name="description" /><meta content="clojure, emacs, clj-refactor, refactor" name="keywords" /><meta content="Benedek Fazekas" name="author" /><link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css" rel="stylesheet" type="text/css" /><link href="//fonts.googleapis.com/css?family=Source+Code+Pro|Open+Sans" rel="stylesheet" type="text/css" /><link href="/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="/custom.css" rel="stylesheet" type="text/css" /><title>Clean up a messy namespace with cider and clj-refactor</title></head><body><div class="content"><div class="container"><div class="row"><div class="col-md-8"><div class="page-header"><h1>Clean up a messy namespace with cider and clj-refactor</h1></div><div class="entry"><p>On <a href="https://skillsmatter.com/conferences/6861-clojure-exchange-2015"><strong>clojureX</strong></a> this year we almost had a panel discussion on editors; it was cancelled at the last minute unfortunately. So I thought why not publish the longer version of the screencast I prepared demonstrating how to use some <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki"><strong>clj-refactor</strong></a> features in Emacs to clean up a messy namespace.</p><p>I highly recommend <a href="http://www.parens-of-the-dead.com"><strong>Parens of the dead</strong></a> to everybody by the way. The series is real joy to watch and demonstrates many things, among them is how to use Emacs with <a href="https://github.com/clojure-emacs/cider"><strong>cider</strong></a> and <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki"><strong>clj-refactor</strong></a> to work with clojure code in a very effective way. On the other hand Magnar uses a certain bunch of clj-refactor features possibly because he builds his project up from scratch. In my brief demo/screencast I'd like to rather demo some features which are very helpful in an other typical refactoring scenario: when you want to clean up an already existing (legacy?!) namespace.</p><p>Also both cider and clj-refactor has so many features now that discoverability is an issue. This screencast and the <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki/hydra-code"><strong>demonstrated use</strong></a> of <a href="https://github.com/abo-abo/hydra"><strong>hydras</strong></a> tries to offer some remedies for that too.</p><p><iframe width="630" height="473" src="https://www.youtube.com/embed/mOSUE3czp9w?rel=0&vq=large" frameborder="0" allowfullscreen></iframe></p><h4><code>ml</code> move to let</h4><p>Move the current form to the closest <code>let</code>. More details <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-move-to-let"><strong>here</strong></a>. This is an elisp only feature meaning that you don't even need a running REPL to use it.</p><h4><code>rs</code> rename (local) symbol</h4><p>Rename all occurrences of a local symbol. More details <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-rename-symbol#or-a-locally-defined-symbol"><strong>here</strong></a>. This is a feature which uses the analyzer to figure out the location of the local symbol therefore you need a running REPL with <a href="https://github.com/clojure-emacs/refactor-nrepl"><strong>refactor-nrepl</strong></a> middleware added to it.</p><h4><code>is</code> inline symbol</h4><p>Inline all occurrences of the symbol at point. Can be used both globally and locally. See screencast gif <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-inline-symbol"><strong>here</strong></a>. Again this is feature needing the analyzer to figure out the location of the occurrences of the symbol you want to inline.</p><h4><code>pf</code> promote function</h4><p>Can promote <code>#(foo %)</code> style anonymus function to <code>(fn [arg1] (foo arg1))</code> or all the way to first level <code>defn</code> or a <code>(fn [arg1] (foo arg1))</code> style anonymus function into a first level defn. See details <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-promote-function#promote-anonymous-function-to-defn"><strong>here</strong></a>. Again this needs the analyzer.</p><h4><code>ef</code> extract function</h4><p>Extract the form at point, or the nearest enclosing form, into a toplevel defn. Newly created function is either private or public, depending on <code>cljr-favor-private-functions</code>. See a screencast <a href="https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-extract-function"><strong>here</strong></a>. This needs the analyzer as well to figure out which locally bound vars the s-expression uses that need to be turned into arguments in the new function.</p></div></div><div class="col-md-4"></div><div class="col-md-12 post-tags">Tags: <a href="/tags/#clojure,">clojure, </a><a href="/tags/#emacs,">emacs, </a><a href="/tags/#clj-refactor,">clj-refactor, </a><a href="/tags/#refactor">refactor </a></div></div></div><script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=clj&amp;lang=ruby"></script><div class="footer"><div class="container"><div class="row"><div class="col-md-12"><p>Built with <a href="http://getbootstrap.com/">Bootstrap</a> and <a href="https://github.com/nakkaya/static">Static</a><br /><p>&copy; 2014-2016 Benedek Fazekas | <a href="https://github.com/benedekfazekas">@github</a> | <a href="https://twitter.com/bfazek">@twitter</a> | </p></p></div></div></div></div></div></body></html>