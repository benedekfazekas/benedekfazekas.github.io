<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<rss version="2.0"><channel><title>Of Herbs and Stewed Rabbit</title><link>https://github.com/nakkaya/static</link><description>Of Herbs and Stewed Rabbit</description><item><title>Laziness driven changelogs</title><link>https://github.com/2015/01/05/laziness-driven-changelogs/</link><pubDate>Mon, 5 Jan 2015 00:00:00 +0000</pubDate><description>&lt;p&gt;At the MailOnline we have not been doing &lt;a href=&quot;https://twitter.com/javame/status/489338291494207488&quot;&gt;microservices&lt;/a&gt; exactly but something definitely far from big, monolithic applications. This resulted in quite a few applications across the board. Many written in clojure or in node.js, javascript for the browser, or some other language. We developers take care of releasing our software which is perhaps the right way to go most of the times, using some &lt;a href=&quot;http://martinfowler.com/articles/continuousIntegration.html&quot;&gt;CI&lt;/a&gt; tool and always trying to push for &lt;a href=&quot;http://martinfowler.com/bliki/ContinuousDelivery.html&quot;&gt;continuous delivery&lt;/a&gt;. Nevertheless the time had come when we were asked to provide some human readable information about the versions of the software we release. The request come from multiple sources: devs, devops and technical management all wanted this info. For a short time we could repel the requests by pointing people to our CI tool and/or gitlogs either in the command line or on github which we use to host almost all our projects -- rest is on bitbucket, just to make things even harder to track. On the top of that we use multiple issue tracking systems, yeah I know, don't ask: historical reasons. As these issues have very valuable information on what we are working on they should be referenced in these changelogs too.&lt;/p&gt;&lt;p&gt;When we realised that we can't really escape the changelog, release note request and to track things would actually help ourselves too we had practically to ways to go: either write these changelogs manually or write some code to generate them for us. Luckily almost from the beginning we were fairly good writing commit messages -- I read that some people actually use git hooks to validate commit messages and enforce certain rules: we are not that good but everybody in the group writes a meaningful one liner at least, referencing github or JIRA issues using tags like &lt;code&gt;[wip]&lt;/code&gt; or &lt;code&gt;[refactor]&lt;/code&gt;. That is fairly good base to build on.&lt;/p&gt;&lt;p&gt;On an other note a long annoyance of mine the release creation on github: why, oh why can't you automatically generate some changelog on github based on your commit messages? I am sure that would not work for everybody who wants to use the release facility on github but it should do it for many projects. So first round: let's do a bit of googling if the tool is already out there. Well... kinda... &lt;a href=&quot;https://pypi.python.org/pypi/gitchangelog&quot;&gt;gitchangelog&lt;/a&gt; looks like exactly what we need. But looking at its sample config file: not that sure anymore. So I basically figured writing something with a similar set of features with simpler config, less code and easy to use for any project but even easier for clojure projects would be fun.&lt;/p&gt;&lt;p&gt;Hence happened &lt;a href=&quot;https://github.com/MailOnline/gargamel&quot;&gt;gargamel&lt;/a&gt; which can be used as a leiningen plugin or with its CLI interface. It accepts any git refs to generate a changelog in between or can generate release notes between the two latest occurrence of some tags with a specific format (for example &lt;code&gt;v\d\.\d\.\d&lt;/code&gt;). It uses mustache templates to generate practically any output format (tested with html and markdown) and with simple &lt;a href=&quot;https://github.com/MailOnline/gargamel/blob/master/gargamel.edn&quot;&gt;configuration&lt;/a&gt; based on regexes it generates custom sections and munges certain objects (like creating links to github/jira issues from issue references) in the commit messages. On the top of that it is able to merge data from several projects into one change log based on a &lt;a href=&quot;http://bower.io/&quot;&gt;bower.json&lt;/a&gt; file.&lt;/p&gt;&lt;p&gt;So now we are able to plugin in change log and release note generation into our release process. We have two types of release note generation jobs on our CI tool: manual one where you can provide &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; git refs: this is used to generate changelog for release candidates and publish them in the appropriate chatrooms (we use &lt;a href=&quot;https://slack.com/&quot;&gt;slack&lt;/a&gt; heavily) for affected people to review. And we have an automated release note generation step which runs right after our production release. Integrating gargamel with CI and slack is the real win in this story. On the top of that on those open source projects I am involved in I can use gargamel now to create markdown changelogs for github releases. for example gargamel's own &lt;a href=&quot;https://github.com/MailOnline/gargamel/releases/tag/release-050-20150113_1225&quot;&gt;release notes&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Clean clojure files en masse continued</title><link>https://github.com/2014/03/24/clean-clj-project-en-masse-2/</link><pubDate>Mon, 24 Mar 2014 00:00:00 +0000</pubDate><description>&lt;p&gt;The project clean mentioned at the end of the previous post got integrated into &lt;a href=&quot;https://github.com/magnars/clj-refactor.el&quot;&gt;&lt;strong&gt;clj-refactor&lt;/strong&gt;&lt;/a&gt; and changed a bit during the process. Just a quicky about the code.&lt;/p&gt;
&lt;!--?prettify lang=emacs-lisp linenums=true --&gt;
&lt;pre&gt;&lt;code&gt;(defun cljr-project-clean ()
  (interactive)
  (when (or (not cljr-project-clean-prompt)
            (yes-or-no-p &amp;quot;Cleaning your project might change many of your clj files. Do you want to proceed?&amp;quot;))
    (dolist (filename (cljr--project-files))
      (when (s-ends-with? &amp;quot;clj&amp;quot; filename)
        (let ((buffer (get-file-buffer filename))
              find-file-p)
          (if buffer
              (set-buffer buffer)
            (setq find-file-p t)
            (find-file filename))
          (ignore-errors (-map &amp;#39;funcall cljr-project-clean-functions))
          (save-buffer)
          (when find-file-p
            (kill-buffer)))))))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are a few small changes basically just to make the this more configurable and more comfortable to use.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Line 3&lt;/strong&gt;: There is a &lt;code&gt;defcustom&lt;/code&gt; controlling if &lt;strong&gt;clj-refactor&lt;/strong&gt; should make sure that we want to proceed with a possible destructive change (en masse). Easy to get rid of this: &lt;code&gt;(setq cljr-project-clean-prompt nil)&lt;/code&gt; if we know what we are doing.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Line 7&lt;/strong&gt;: &lt;strong&gt;clj-refactor&lt;/strong&gt; nicely tries to find the buffer first. If it is found it uses it and then won't get killed when all the changes are done (see &lt;strong&gt;line 15&lt;/strong&gt;): there is a good guy. Otherwise we open the file with &lt;code&gt;find-file&lt;/code&gt; and kill it when done. Would be interesting to find a way to use &lt;code&gt;temp-buffer&lt;/code&gt; and/or &lt;code&gt;temp-file&lt;/code&gt; actually.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Line 13&lt;/strong&gt;: There is an other &lt;code&gt;defcustom&lt;/code&gt; to configure the list of functions to run on a given clojure file in the project. By default this is removing unusued requires and sort ns forms but easy to remove one of these or add others, even perhaps some project dependent cleaning functions implemented in the project itself.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Hope that really helps out there to fix some broken windows.&lt;/p&gt;</description></item><item><title>Clean clojure files en masse</title><link>https://github.com/2014/03/16/clean-clj-project-en-masse/</link><pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate><description>&lt;p&gt;&lt;a href=&quot;https://github.com/magnars/clj-refactor.el&quot;&gt;&lt;strong&gt;clj-refactor&lt;/strong&gt;&lt;/a&gt; is a very lightweight elisp library for Emacs to support every day refactorings for clojure. I've even read that it is an &lt;a href=&quot;https://twitter.com/cemerick/statuses/431608319552548864&quot;&gt;Ã¼ber-paredit&lt;/a&gt;: kinda fair. It definitely melds into the editing experience defined by the mix of cider, clojure-mode, paredit well. Adopting it you get loads of nice transformations which help you with your every day clojure coding. There are simpler ones like &lt;strong&gt;add require to namespace declaration&lt;/strong&gt; &lt;code&gt;ar&lt;/code&gt; and &lt;strong&gt;cycle collection type&lt;/strong&gt; &lt;code&gt;cc&lt;/code&gt; or &lt;strong&gt;cycle privacy&lt;/strong&gt; &lt;code&gt;cp&lt;/code&gt;. This latter sounds silly first: why an earth you would not just go to your &lt;code&gt;defn&lt;/code&gt; and add that '-' to make it private. But once your muscle memory has remembered &lt;code&gt;cp&lt;/code&gt; it is just natural to turn a function private with one easy key combo when you figured out it does not make sense to keep it public -- you don't even need to think about what to press. There are more arcane ones which give the wtf-just-happened-with-my-code experience first but then they start making absolute sense. The threading macro related ones for example: &lt;strong&gt;wrap in thread first&lt;/strong&gt; &lt;code&gt;tf&lt;/code&gt; and &lt;strong&gt;fully unwind threaded expression&lt;/strong&gt; &lt;code&gt;ua&lt;/code&gt; or the &lt;strong&gt;introduce let&lt;/strong&gt;, &lt;strong&gt;expand let&lt;/strong&gt;, &lt;strong&gt;move to let&lt;/strong&gt; triumvirate. Used in a correct way the latter one helps you to handle let expressions in a very clean way across your code. These are only examples of course, check out the full list on the project's really cleanly written github readme.&lt;/p&gt;
&lt;hr/&gt;
&lt;div class=&quot;sidenote&quot;&gt;

Just a side note on the shortcuts.  Well, that is the usual Emacs story.  People tend to freak out: 'not that many extra key combination I need to learn again'.  I find that my muscle memory kicks in very fast and what is even more helpful it is contextual.  I don't even try certain key combos when in the repl or when editing a text file.  So after a bit of practice you won't need to think how to move the form after the cursor to the already existing let expression.

&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;I also mentioned that &lt;strong&gt;clj-refactor&lt;/strong&gt; is lightweight. It is in the sense that it does not use any code analyzer library or such and it does not enforce you to use &lt;a href=&quot;https://github.com/clojure-emacs/cider&quot;&gt;&lt;strong&gt;cider&lt;/strong&gt;&lt;/a&gt; either. (Cider still can come in handy. For example you can use completion when adding something to the require section in your ns declaration.) It is an emacs-lisp library -- started out as tiny -- which uses some other elisp libraries like paredit, yasnippet, dash.el, s.el, multiple cursors (the good work of &lt;a href=&quot;https://github.com/magnars&quot;&gt;Magnar Sveen&lt;/a&gt; and others just like &lt;strong&gt;clj-refactor&lt;/strong&gt; itself). So &lt;strong&gt;clj-refactor&lt;/strong&gt; does not really 'understand' your code, but by using paredit it does understand the structure of your clojure files. This with some more elisp foo gives it enough power to be extremely handy: &lt;strong&gt;clj-refactor&lt;/strong&gt; is not so tiny anymore. There are plans to add some code analyzer to the mix but to be honest I would prefer at least to keep that if ever added as an optional feature even with the drawback of falling back to simpler behaviour. Lightweight means fast and speed is extremely important in order to avoid the productivity killer &lt;strong&gt;IDE&lt;/strong&gt; experience.&lt;/p&gt;&lt;p&gt;That leads me to the next group of offered refactorings, the ones which need to be performant because it makes sense to run them against a whole bunch of clojure files in one go. These are the 'clean up', house keeping features:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;replace &lt;code&gt;use&lt;/code&gt; with &lt;code&gt;:refer :all&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sort use, require and import in your ns form&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;remove unused requires&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;When working on a sort of larger clojure project or multiple of those or as a member of a team of six, eight plus developers you might find running these against a whole project periodically a really nice thing as it helps fixing the &lt;a href=&quot;http://blog.codinghorror.com/the-broken-window-theory/&quot;&gt;broken window&lt;/a&gt; effect. I personally am not really a big fan of coding conventions, rules of how to write code or code style checkers but the number of namespaces which have unused requires is a good indicator of how much the code started to get disorganised. Better to fix those as fast as possible.&lt;/p&gt;&lt;p&gt;Here comes a small elisp function which does the trick:&lt;/p&gt;
&lt;!--?prettify lang=emacs-lisp--&gt;
&lt;pre&gt;&lt;code&gt;(defun cleanup-project-clj-files ()
  (interactive)
  (dolist (filename (cljr--project-files))
    (when (s-ends-with? &amp;quot;clj&amp;quot; filename)
      (find-file filename)
      (ignore-errors (cljr-remove-unused-requires))
      (save-buffer)
      (kill-buffer))))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Some quick points about the above code. It uses &lt;strong&gt;clj-refactor&lt;/strong&gt;'s own &lt;code&gt;cljr--project-files&lt;/code&gt; to find the clojure files. There are other ways but I thought the best is to use this as we are anyway using this library. One caveat that it will only work with leiningen managed projects for now. There are plans in the project as far as I know to eventually improve this. When that is done the above script will start working for any kind of projects. &lt;code&gt;ignore errors&lt;/code&gt; is needed because there is an error thrown if the given file does not have an ns declaration (as the project file itself does not). &lt;code&gt;save buffer&lt;/code&gt; might also trigger some additional clean up if you some hooks defined on save. For example my Emacs configuration turns all tabs into spaces when I save. Adding the above function to your Emacs is easy: either just copy it into your Emacs init file or save it in a separate file and make sure that file is loaded via your &lt;code&gt;init.el&lt;/code&gt;. If that is done you can just open any files in the project and &lt;code&gt;M-x cleanup-project-clj-files&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I saw something very similar originally in &lt;a href=&quot;https://github.com/AlexBaranosky&quot;&gt;Alex Baranosky&lt;/a&gt;'s Emacs config repo on github and simplified it a bit. Also lots of information in the post comes from Alex and the small team around &lt;strong&gt;clj-refactor&lt;/strong&gt; while chatting with them about my pull requests. A very nice, fun team around a fun project.&lt;/p&gt;</description></item></channel></rss>